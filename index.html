<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Major Express - –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –º–∞—Ä—à—Ä—É—Ç–∞</title>
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#0f172a">
    <link rel="manifest" href='data:application/json;charset=utf-8,{"name":"Major Express","short_name":"MajorExp","start_url":".","display":"standalone","background_color":"#0f172a","theme_color":"#0f172a","icons":[{"src":"https://cdn-icons-png.flaticon.com/512/2830/2830305.png","sizes":"512x512","type":"image/png"}]}'>
    <link rel="apple-touch-icon" href="https://cdn-icons-png.flaticon.com/512/2830/2830305.png">
    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <style>
        #map { height: 500px; width: 100%; border-radius: 12px; }
        .drag-handle { cursor: grab; }
        .drag-handle:active { cursor: grabbing; }
        .address-item { transition: all 0.2s ease; }
        .address-item:hover { transform: translateX(5px); }
        .pulse { animation: pulse 2s infinite; }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        .recording { 
            animation: recording-pulse 1s infinite; 
            box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7);
        }
        @keyframes recording-pulse {
            0% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7); }
            70% { box-shadow: 0 0 0 15px rgba(239, 68, 68, 0); }
            100% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0); }
        }
        .voice-wave {
            display: flex;
            align-items: center;
            gap: 3px;
            height: 20px;
        }
        .voice-wave span {
            width: 3px;
            background: white;
            border-radius: 2px;
            animation: wave 0.5s infinite ease-in-out;
        }
        .voice-wave span:nth-child(1) { animation-delay: 0s; height: 8px; }
        .voice-wave span:nth-child(2) { animation-delay: 0.1s; height: 16px; }
        .voice-wave span:nth-child(3) { animation-delay: 0.2s; height: 12px; }
        .voice-wave span:nth-child(4) { animation-delay: 0.3s; height: 18px; }
        .voice-wave span:nth-child(5) { animation-delay: 0.4s; height: 10px; }
        @keyframes wave {
            0%, 100% { transform: scaleY(1); }
            50% { transform: scaleY(0.5); }
        }
        
        /* Toast Notifications */
        .toast-enter { transform: translateX(100%); opacity: 0; }
        .toast-enter-active { transform: translateX(0); opacity: 1; transition: all 0.3s ease-out; }
        .toast-exit { transform: translateX(0); opacity: 1; }
        .toast-exit-active { transform: translateX(100%); opacity: 0; transition: all 0.3s ease-in; }
        
        /* Completed Item */
        .address-completed {
            opacity: 0.6;
            background: rgba(255, 255, 255, 0.02) !important;
        }
        .address-completed .text-white {
            text-decoration: line-through;
            color: rgba(255, 255, 255, 0.5);
        }
        .notes-input {
            transition: all 0.2s;
        }
        .notes-input:focus {
            background: rgba(0, 0, 0, 0.3);
        }

        /* History Markers */
        .history-marker-icon {
            background: #64748b;
            border: 2px solid white;
            border-radius: 50%;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            opacity: 0.7;
            transition: all 0.2s;
        }
        .history-marker-icon:hover {
            background: #f97316;
            transform: scale(1.2);
            opacity: 1;
            z-index: 1000;
            cursor: pointer;
        }
        
        /* Scrollbar */
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: rgba(255, 255, 255, 0.1); }
        ::-webkit-scrollbar-thumb { background: rgba(255, 255, 255, 0.3); border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: rgba(255, 255, 255, 0.5); }
    </style>
</head>
<body class="bg-gradient-to-br from-slate-900 via-blue-900 to-slate-900 min-h-screen">
    <div class="container mx-auto px-4 py-6">
        <!-- Header -->
        <header class="text-center mb-6 relative px-2">
            <div class="inline-flex items-center gap-3 bg-white/10 backdrop-blur-sm px-4 py-2 rounded-xl max-w-full">
                <div class="w-10 h-10 bg-gradient-to-r from-orange-500 to-red-500 rounded-lg flex-shrink-0 flex items-center justify-center">
                    <svg class="w-6 h-6 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16V6a1 1 0 00-1-1H4a1 1 0 00-1 1v10a1 1 0 001 1h1m8-1a1 1 0 01-1 1H9m4-1V8a1 1 0 011-1h2.586a1 1 0 01.707.293l3.414 3.414a1 1 0 01.293.707V16a1 1 0 01-1 1h-1m-6-1a1 1 0 001 1h1M5 17a2 2 0 104 0m-4 0a2 2 0 114 0m6 0a2 2 0 104 0m-4 0a2 2 0 114 0"></path>
                    </svg>
                </div>
                <div class="text-left min-w-0">
                    <h1 class="text-lg font-bold text-white leading-tight truncate">Major Express</h1>
                    <p class="text-blue-300 text-xs truncate">–û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –º–∞—Ä—à—Ä—É—Ç–∞</p>
                </div>
            </div>
            
            <!-- Help Button -->
            <button onclick="toggleHelpModal()" class="absolute left-0 top-1/2 -translate-y-1/2 bg-white/10 hover:bg-white/20 text-white p-3 rounded-xl transition-colors" title="–°–ø—Ä–∞–≤–∫–∞">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8.228 9c.549-1.165 2.03-2 3.772-2 2.21 0 4 1.343 4 3 0 1.4-1.278 2.575-3.006 2.907-.542.104-.994.54-.994 1.093m0 3h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                </svg>
            </button>

            <!-- History Button -->
            <button onclick="toggleHistoryModal()" class="absolute right-0 top-1/2 -translate-y-1/2 bg-white/10 hover:bg-white/20 text-white p-3 rounded-xl transition-colors" title="–ò—Å—Ç–æ—Ä–∏—è –∞–¥—Ä–µ—Å–æ–≤">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                </svg>
            </button>
        </header>

        <div class="grid lg:grid-cols-2 gap-6">
            <!-- Left Panel - Address Input -->
            <div class="space-y-6">
                <!-- Start Point -->
                <div class="bg-white/10 backdrop-blur-sm rounded-2xl p-5">
                    <h2 class="text-lg font-semibold text-white mb-4 flex items-center gap-2">
                        <span class="w-8 h-8 bg-green-500 rounded-full flex items-center justify-center text-white text-sm font-bold">–ê</span>
                        –ù–∞—á–∞–ª—å–Ω–∞—è —Ç–æ—á–∫–∞
                    </h2>
                    <div class="flex gap-2">
                        <input type="text" id="startAddress" placeholder="–û—Ç–∫—É–¥–∞ –Ω–∞—á–∏–Ω–∞–µ—Ç–µ –º–∞—Ä—à—Ä—É—Ç..." 
                            class="flex-1 bg-white/10 border border-white/20 rounded-xl px-4 py-3 text-white placeholder-white/50 focus:outline-none focus:ring-2 focus:ring-orange-500">
                        <button onclick="setStartPoint()" class="bg-green-500 hover:bg-green-600 text-white px-5 py-3 rounded-xl font-medium transition-colors">
                            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17.657 16.657L13.414 20.9a1.998 1.998 0 01-2.827 0l-4.244-4.243a8 8 0 1111.314 0z"></path>
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 11a3 3 0 11-6 0 3 3 0 016 0z"></path>
                            </svg>
                        </button>
                    </div>
                    <div id="startPointDisplay" class="mt-3 text-green-400 text-sm hidden"></div>
                </div>

                <!-- Voice Input - Big Button -->
                <div class="bg-gradient-to-r from-red-500/20 to-orange-500/20 backdrop-blur-sm rounded-2xl p-5 border border-red-500/30">
                    <h2 class="text-lg font-semibold text-white mb-4 flex items-center gap-2">
                        <svg class="w-6 h-6 text-red-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 11a7 7 0 01-7 7m0 0a7 7 0 01-7-7m7 7v4m0 0H8m4 0h4m-4-8a3 3 0 01-3-3V5a3 3 0 116 0v6a3 3 0 01-3 3z"></path>
                        </svg>
                        –ì–æ–ª–æ—Å–æ–≤–æ–π –≤–≤–æ–¥ –∞–¥—Ä–µ—Å–æ–≤
                    </h2>
                    <button onclick="toggleVoiceRecording()" id="voiceBtn" 
                        class="w-full bg-gradient-to-r from-red-500 to-red-600 hover:from-red-600 hover:to-red-700 text-white py-6 rounded-2xl font-bold text-xl transition-all transform hover:scale-[1.02] shadow-lg flex items-center justify-center gap-3">
                        <svg id="micIcon" class="w-8 h-8" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 11a7 7 0 01-7 7m0 0a7 7 0 01-7-7m7 7v4m0 0H8m4 0h4m-4-8a3 3 0 01-3-3V5a3 3 0 116 0v6a3 3 0 01-3 3z"></path>
                        </svg>
                        <span id="voiceBtnText">–ù–∞–∂–º–∏—Ç–µ –∏ –≥–æ–≤–æ—Ä–∏—Ç–µ –∞–¥—Ä–µ—Å</span>
                        <div id="voiceWave" class="voice-wave hidden">
                            <span></span><span></span><span></span><span></span><span></span>
                        </div>
                    </button>
                    <div id="voiceStatus" class="mt-3 text-center text-white/70 text-sm">
                        –ì–æ–≤–æ—Ä–∏—Ç–µ –∞–¥—Ä–µ—Å–∞ –æ–¥–∏–Ω –∑–∞ –¥—Ä—É–≥–∏–º ‚Äî –æ–Ω–∏ –¥–æ–±–∞–≤—è—Ç—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏
                    </div>
                    <div id="recognizedText" class="mt-3 bg-white/10 rounded-xl px-4 py-3 text-white hidden">
                        <span class="text-white/50 text-sm">–†–∞—Å–ø–æ–∑–Ω–∞–Ω–æ: </span>
                        <span id="recognizedAddress" class="font-medium"></span>
                    </div>
                </div>

                <!-- Add Addresses -->
                <div class="bg-white/10 backdrop-blur-sm rounded-2xl p-5">
                    <h2 class="text-lg font-semibold text-white mb-4 flex items-center gap-2">
                        <svg class="w-6 h-6 text-orange-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"></path>
                        </svg>
                        –ò–ª–∏ –≤–≤–µ–¥–∏—Ç–µ –≤—Ä—É—á–Ω—É—é
                    </h2>
                    <div class="flex gap-2 mb-3">
                        <div class="flex-1 flex gap-2 bg-white/10 border border-white/20 rounded-xl p-1 focus-within:ring-2 focus-within:ring-orange-500 transition-all">
                            <input type="text" id="addressInput" placeholder="–ê–¥—Ä–µ—Å (–Ω–∞–ø—Ä–∏–º–µ—Ä: –¢–≤–µ—Ä—Å–∫–∞—è 15)" 
                                class="flex-1 bg-transparent border-none text-white placeholder-white/50 px-3 py-2 focus:outline-none focus:ring-0"
                                onkeypress="if(event.key==='Enter') addAddress()">
                            <div class="w-px bg-white/20 my-1"></div>
                            <input type="time" id="timeInput" 
                                class="bg-transparent border-none text-white/80 text-sm px-2 py-2 focus:outline-none focus:ring-0 cursor-pointer"
                                title="–í—Ä–µ–º—è –¥–æ—Å—Ç–∞–≤–∫–∏ (–Ω–µ–æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ)">
                        </div>
                        <button onclick="addAddress()" class="bg-orange-500 hover:bg-orange-600 text-white px-5 py-3 rounded-xl font-medium transition-colors shadow-lg">
                            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"></path></svg>
                        </button>
                    </div>
                    <div class="flex gap-2">
                        <textarea id="bulkAddresses" placeholder="–ò–ª–∏ –≤—Å—Ç–∞–≤—å—Ç–µ –Ω–µ—Å–∫–æ–ª—å–∫–æ –∞–¥—Ä–µ—Å–æ–≤ (–∫–∞–∂–¥—ã–π —Å –Ω–æ–≤–æ–π —Å—Ç—Ä–æ–∫–∏)..." 
                            class="flex-1 bg-white/10 border border-white/20 rounded-xl px-4 py-3 text-white placeholder-white/50 focus:outline-none focus:ring-2 focus:ring-orange-500 h-24 resize-none"></textarea>
                        <button onclick="addBulkAddresses()" class="bg-blue-500 hover:bg-blue-600 text-white px-4 py-3 rounded-xl font-medium transition-colors text-sm">
                            –î–æ–±–∞–≤–∏—Ç—å<br>–≤—Å–µ
                        </button>
                    </div>
                </div>

                <!-- Statistics -->
                <div class="bg-gradient-to-r from-blue-600/20 to-purple-600/20 backdrop-blur-sm rounded-2xl p-5 border border-blue-500/20 mb-6" id="statsPanel">
                    <div class="flex justify-between items-end mb-2">
                        <div>
                            <p class="text-blue-300 text-xs font-bold uppercase tracking-wider">–ü—Ä–æ–≥—Ä–µ—Å—Å –¥–Ω—è</p>
                            <div class="flex items-baseline gap-2">
                                <span class="text-3xl font-bold text-white" id="statCompleted">0</span>
                                <span class="text-white/50 text-sm">–∏–∑ <span id="statTotal">0</span></span>
                            </div>
                        </div>
                        <div class="text-right">
                            <p class="text-white text-sm" id="statPercent">0%</p>
                        </div>
                    </div>
                    <div class="w-full bg-black/30 h-2 rounded-full overflow-hidden">
                        <div id="statBar" class="bg-gradient-to-r from-blue-500 to-purple-500 h-full rounded-full transition-all duration-500" style="width: 0%"></div>
                    </div>
                    <div class="grid grid-cols-2 gap-2 mt-3 pt-3 border-t border-white/10">
                        <div class="text-center">
                            <p class="text-white/40 text-xs">–û—Å—Ç–∞–ª–æ—Å—å</p>
                            <p class="text-white font-bold" id="statRemaining">0</p>
                        </div>
                        <div class="text-center">
                            <p class="text-white/40 text-xs">–ú–∞—Ä—à—Ä—É—Ç</p>
                            <p class="text-white font-bold" id="statDistance">-</p>
                        </div>
                    </div>
                </div>

                <!-- Address List -->
                <div class="bg-white/10 backdrop-blur-sm rounded-2xl p-5">
                    <div class="flex items-center justify-between mb-4">
                        <h2 class="text-lg font-semibold text-white flex items-center gap-2">
                            <svg class="w-6 h-6 text-blue-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2"></path>
                            </svg>
                            –ê–¥—Ä–µ—Å–∞ (<span id="addressCount">0</span>)
                        </h2>
                        <button onclick="clearAllAddresses()" class="text-red-400 hover:text-red-300 text-sm transition-colors">
                            –û—á–∏—Å—Ç–∏—Ç—å –≤—Å—ë
                        </button>
                    </div>
                    <div id="addressList" class="space-y-2 max-h-64 overflow-y-auto pr-2">
                        <p class="text-white/50 text-center py-4">–ê–¥—Ä–µ—Å–∞ –ø–æ–∫–∞ –Ω–µ –¥–æ–±–∞–≤–ª–µ–Ω—ã</p>
                    </div>
                </div>

                <!-- Optimize Button -->
                <button onclick="optimizeRoute()" id="optimizeBtn" 
                    class="w-full bg-gradient-to-r from-orange-500 to-red-500 hover:from-orange-600 hover:to-red-600 text-white py-4 rounded-2xl font-bold text-lg transition-all transform hover:scale-[1.02] shadow-lg disabled:opacity-50 disabled:cursor-not-allowed disabled:transform-none">
                    <span class="flex items-center justify-center gap-2">
                        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 20l-5.447-2.724A1 1 0 013 16.382V5.618a1 1 0 011.447-.894L9 7m0 13l6-3m-6 3V7m6 10l4.553 2.276A1 1 0 0021 18.382V7.618a1 1 0 00-.553-.894L15 4m0 13V4m0 0L9 7"></path>
                        </svg>
                        –ü–æ—Å—Ç—Ä–æ–∏—Ç—å –æ–ø—Ç–∏–º–∞–ª—å–Ω—ã–π –º–∞—Ä—à—Ä—É—Ç
                    </span>
                </button>

                <!-- Export Buttons -->
                <div class="grid grid-cols-2 gap-3">
                    <button onclick="openInYandexMaps()" class="bg-yellow-500 hover:bg-yellow-600 text-black py-3 rounded-xl font-medium transition-colors flex items-center justify-center gap-2">
                        <svg class="w-5 h-5" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z"/>
                        </svg>
                        –Ø–Ω–¥–µ–∫—Å –ö–∞—Ä—Ç—ã
                    </button>
                    <button onclick="openInGoogleMaps()" class="bg-white hover:bg-gray-100 text-gray-800 py-3 rounded-xl font-medium transition-colors flex items-center justify-center gap-2">
                        <svg class="w-5 h-5" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z"/>
                        </svg>
                        Google Maps
                    </button>
                </div>
            </div>

            <!-- Right Panel - Map & Route -->
            <div class="space-y-6">
                <!-- Map -->
                <div class="bg-white/10 backdrop-blur-sm rounded-2xl p-5 relative">
                    <button id="clearHistoryBtn" onclick="clearHistoryPreview()" class="absolute top-20 right-7 z-[400] bg-white text-slate-800 px-4 py-2 rounded-xl shadow-lg text-sm font-bold hidden hover:bg-gray-100 transition-colors border-2 border-slate-200 flex items-center gap-2">
                        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                        –°–∫—Ä—ã—Ç—å –∏—Å—Ç–æ—Ä–∏—é
                    </button>
                    <h2 class="text-lg font-semibold text-white mb-4 flex items-center gap-2">
                        <svg class="w-6 h-6 text-purple-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 20l-5.447-2.724A1 1 0 013 16.382V5.618a1 1 0 011.447-.894L9 7m0 13l6-3m-6 3V7m6 10l4.553 2.276A1 1 0 0021 18.382V7.618a1 1 0 00-.553-.894L15 4m0 13V4m0 0L9 7"></path>
                        </svg>
                        –ö–∞—Ä—Ç–∞ –º–∞—Ä—à—Ä—É—Ç–∞
                    </h2>
                    <div id="map" class="shadow-xl"></div>
                </div>

                <!-- Optimized Route -->
                <div class="bg-white/10 backdrop-blur-sm rounded-2xl p-5">
                    <h2 class="text-lg font-semibold text-white mb-4 flex items-center gap-2">
                        <svg class="w-6 h-6 text-green-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                        </svg>
                        –û–ø—Ç–∏–º–∞–ª—å–Ω—ã–π –ø–æ—Ä—è–¥–æ–∫
                    </h2>
                    <div id="optimizedRoute" class="space-y-2 max-h-80 overflow-y-auto pr-2">
                        <p class="text-white/50 text-center py-4">–ù–∞–∂–º–∏—Ç–µ "–ü–æ—Å—Ç—Ä–æ–∏—Ç—å –º–∞—Ä—à—Ä—É—Ç" –¥–ª—è –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏</p>
                    </div>
                    <div id="routeStats" class="mt-4 pt-4 border-t border-white/10 hidden">
                        <div class="grid grid-cols-2 gap-4 text-center">
                            <div>
                                <p class="text-white/50 text-sm">–û–±—â–µ–µ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ</p>
                                <p class="text-2xl font-bold text-white" id="totalDistance">0 –∫–º</p>
                            </div>
                            <div>
                                <p class="text-white/50 text-sm">–ü—Ä–∏–º–µ—Ä–Ω–æ–µ –≤—Ä–µ–º—è</p>
                                <p class="text-2xl font-bold text-white" id="totalTime">0 –º–∏–Ω</p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Loading Overlay -->
        <div id="loadingOverlay" class="fixed inset-0 bg-black/70 backdrop-blur-sm flex items-center justify-center z-50 hidden">
            <div class="bg-white/10 backdrop-blur-sm rounded-2xl p-8 text-center">
                <div class="w-16 h-16 border-4 border-orange-500 border-t-transparent rounded-full animate-spin mx-auto mb-4"></div>
                <p class="text-white text-lg" id="loadingText">–ì–µ–æ–∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏–µ –∞–¥—Ä–µ—Å–æ–≤...</p>
            </div>
        </div>
    </div>

    <!-- History Modal -->
    <div id="historyModal" class="fixed inset-0 bg-black/80 backdrop-blur-sm z-50 hidden flex items-center justify-center p-4">
        <div class="bg-slate-800 rounded-2xl w-full max-w-2xl max-h-[80vh] flex flex-col shadow-2xl border border-white/10">
            <div class="p-5 border-b border-white/10 flex justify-between items-center">
                <h2 class="text-xl font-bold text-white flex items-center gap-2">
                    <svg class="w-6 h-6 text-blue-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                    </svg>
                    –ò—Å—Ç–æ—Ä–∏—è –ø–æ–µ–∑–¥–æ–∫
                </h2>
                <button onclick="toggleHistoryModal()" class="text-white/50 hover:text-white transition-colors">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                    </svg>
                </button>
            </div>
            <div class="overflow-y-auto p-5 flex-1" id="historyContent">
                <!-- History items will be here -->
            </div>
            <div class="p-4 border-t border-white/10 bg-white/5 rounded-b-2xl flex justify-end">
                <button onclick="toggleHistoryModal()" class="bg-white/10 hover:bg-white/20 text-white px-4 py-2 rounded-xl transition-colors">
                    –ó–∞–∫—Ä—ã—Ç—å
                </button>
            </div>
        </div>
    </div>

    <!-- Help Modal -->
    <div id="helpModal" class="fixed inset-0 bg-black/80 backdrop-blur-sm z-50 hidden flex items-center justify-center p-4">
        <div class="bg-slate-800 rounded-2xl w-full max-w-md flex flex-col shadow-2xl border border-white/10 max-h-[85vh]">
            <div class="p-5 border-b border-white/10 flex justify-between items-center">
                <h2 class="text-xl font-bold text-white">–ö–∞–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è</h2>
                <button onclick="toggleHelpModal()" class="text-white/50 hover:text-white">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                </button>
            </div>
            <div class="p-5 overflow-y-auto text-white space-y-4">
                <div>
                    <h3 class="text-orange-400 font-bold mb-1">üé§ –ì–æ–ª–æ—Å–æ–≤–æ–π –≤–≤–æ–¥</h3>
                    <p class="text-sm text-white/70">–ù–∞–∂–º–∏—Ç–µ –∫—Ä–∞—Å–Ω—É—é –∫–Ω–æ–ø–∫—É –∏ –≥–æ–≤–æ—Ä–∏—Ç–µ: <br><i>"–õ–µ–Ω–∏–Ω–∞ 5 <b>–∫ 14:30</b>"</i>. –í—Ä–µ–º—è —Ä–∞—Å–ø–æ–∑–Ω–∞–µ—Ç—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏.</p>
                </div>
                <div>
                    <h3 class="text-blue-400 font-bold mb-1">üì± –£—Å—Ç–∞–Ω–æ–≤–∫–∞ –Ω–∞ —Ç–µ–ª–µ—Ñ–æ–Ω</h3>
                    <p class="text-sm text-white/70"><b>iPhone:</b> –ù–∞–∂–º–∏—Ç–µ "–ü–æ–¥–µ–ª–∏—Ç—å—Å—è" -> "–ù–∞ —ç–∫—Ä–∞–Ω –î–æ–º–æ–π".<br><b>Android:</b> –ú–µ–Ω—é (3 —Ç–æ—á–∫–∏) -> "–£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ".</p>
                </div>
                <div>
                    <h3 class="text-green-400 font-bold mb-1">üöö –ú–∞—Ä—à—Ä—É—Ç</h3>
                    <p class="text-sm text-white/70">–°–∏—Å—Ç–µ–º–∞ —Å–∞–º–∞ —Å—Ç—Ä–æ–∏—Ç –º–∞—Ä—à—Ä—É—Ç. –ï—Å–ª–∏ –ø–æ—Ä—è–¥–æ–∫ –Ω–µ –Ω—Ä–∞–≤–∏—Ç—Å—è ‚Äî –ø—Ä–æ—Å—Ç–æ <b>–ø–µ—Ä–µ—Ç–∞—â–∏—Ç–µ</b> –∞–¥—Ä–µ—Å –≤ —Å–ø–∏—Å–∫–µ –ø–∞–ª—å—Ü–µ–º!</p>
                </div>
                <div>
                    <h3 class="text-purple-400 font-bold mb-1">‚úÖ –í —Ä–∞–±–æ—Ç–µ</h3>
                    <ul class="list-disc list-inside text-sm text-white/70 ml-1">
                        <li>–ñ–º–∏—Ç–µ –≥–∞–ª–æ—á–∫—É (–Ω–æ–º–µ—Ä), –∫–æ–≥–¥–∞ –æ—Ç–¥–∞–ª–∏ –∑–∞–∫–∞–∑.</li>
                        <li>–ü–∏—à–∏—Ç–µ –∫–æ–¥—ã/—ç—Ç–∞–∂–∏ –≤ –ø–æ–ª–µ "–ó–∞–º–µ—Ç–∫–∏".</li>
                        <li>–°–º–æ—Ç—Ä–∏—Ç–µ –∏—Å—Ç–æ—Ä–∏—é –ø–æ–µ–∑–¥–æ–∫ —á–µ—Ä–µ–∑ –∫–Ω–æ–ø–∫—É üïí.</li>
                    </ul>
                </div>
            </div>
            <div class="p-4 border-t border-white/10 bg-white/5 rounded-b-2xl">
                <button onclick="toggleHelpModal()" class="w-full bg-blue-600 hover:bg-blue-700 text-white py-3 rounded-xl font-bold transition-colors">
                    –ü–æ–Ω—è—Ç–Ω–æ!
                </button>
            </div>
        </div>
    </div>

    <!-- Toast Container -->
    <div id="toastContainer" class="fixed top-24 right-4 z-50 flex flex-col gap-2 pointer-events-none"></div>

    <script>
        // Initialize map
        const map = L.map('map').setView([55.7558, 37.6173], 11);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '¬© OpenStreetMap contributors'
        }).addTo(map);

        let addresses = [];
        let startPoint = null;
        let markers = [];
        let routeLine = null;
        let historyLayer = L.layerGroup().addTo(map);
        let addressHistory = [];

        // History & Toast Functions
        function showToast(message, type = 'info') {
            const container = document.getElementById('toastContainer');
            const toast = document.createElement('div');
            
            let bgClass = type === 'warning' ? 'bg-orange-500' : 'bg-blue-600';
            let icon = type === 'warning' 
                ? '<svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>'
                : '<svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>';

            toast.className = `toast-enter flex items-center gap-3 ${bgClass} text-white px-4 py-3 rounded-xl shadow-xl backdrop-blur-sm max-w-sm`;
            toast.innerHTML = `
                ${icon}
                <span class="text-sm font-medium">${message}</span>
            `;

            container.appendChild(toast);

            // Animate in
            requestAnimationFrame(() => {
                toast.classList.remove('toast-enter');
                toast.classList.add('toast-enter-active');
            });

            // Remove after 3s
            setTimeout(() => {
                toast.classList.remove('toast-enter-active');
                toast.classList.add('toast-exit-active');
                setTimeout(() => toast.remove(), 300);
            }, 3000);
        }

        function addToHistory(addr) {
            const today = new Date().toLocaleDateString('ru-RU');
            const existsToday = addressHistory.find(h => h.address === addr.address && h.date === today);
            
            if (!existsToday) {
                addressHistory.unshift({ 
                    ...addr, 
                    date: today, 
                    timestamp: Date.now() 
                });
                localStorage.setItem('majorExpressHistory', JSON.stringify(addressHistory));
            }
        }

        function checkHistory(addressText) {
            const today = new Date().toLocaleDateString('ru-RU');
            // Find previous visit NOT from today
            const found = addressHistory.find(h => 
                h.address.toLowerCase() === addressText.toLowerCase() && 
                h.date !== today
            );
            return found ? found.date : null;
        }

        function toggleHelpModal() {
            const modal = document.getElementById('helpModal');
            modal.classList.toggle('hidden');
        }

        function toggleHistoryModal() {
            const modal = document.getElementById('historyModal');
            if (modal.classList.contains('hidden')) {
                modal.classList.remove('hidden');
                renderHistory();
            } else {
                modal.classList.add('hidden');
            }
        }

        function renderHistory() {
            const container = document.getElementById('historyContent');
            if (addressHistory.length === 0) {
                container.innerHTML = '<p class="text-white/50 text-center">–ò—Å—Ç–æ—Ä–∏—è –ø—É—Å—Ç–∞</p>';
                return;
            }

            // Group by date
            const grouped = {};
            addressHistory.forEach(item => {
                if (!grouped[item.date]) grouped[item.date] = [];
                grouped[item.date].push(item);
            });

            container.innerHTML = Object.keys(grouped).map(date => `
                <div class="mb-6">
                    <div class="sticky top-0 bg-slate-800 py-2 border-b border-white/5 flex justify-between items-center mb-3 z-10">
                        <h3 class="text-blue-300 font-bold">${date}</h3>
                        <div class="flex gap-2">
                            <button onclick="previewHistoryOnMap('${date}')" class="text-xs bg-white/10 hover:bg-white/20 text-white px-2 py-1 rounded transition-colors flex items-center gap-1" title="–ü–æ–∫–∞–∑–∞—Ç—å –Ω–∞ –∫–∞—Ä—Ç–µ">
                                <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 20l-5.447-2.724A1 1 0 013 16.382V5.618a1 1 0 011.447-.894L9 7m0 13l6-3m-6 3V7m6 10l4.553 2.276A1 1 0 0021 18.382V7.618a1 1 0 00-.553-.894L15 4m0 13V4m0 0L9 7"></path></svg>
                                –ù–∞ –∫–∞—Ä—Ç–µ
                            </button>
                            <button onclick="addAllFromDate('${date}')" class="text-xs bg-blue-500/20 hover:bg-blue-500/40 text-blue-300 px-2 py-1 rounded transition-colors flex items-center gap-1" title="–î–æ–±–∞–≤–∏—Ç—å –≤—Å–µ –≤ —Ç–µ–∫—É—â–∏–π –º–∞—Ä—à—Ä—É—Ç">
                                <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"></path></svg>
                                –í—Å–µ –≤ –º–∞—Ä—à—Ä—É—Ç
                            </button>
                        </div>
                    </div>
                    <div class="space-y-2">
                        ${grouped[date].map(item => `
                            <div class="bg-white/5 rounded-lg px-3 py-2 flex items-center justify-between group hover:bg-white/10 transition-colors">
                                <div>
                                    <span class="text-white text-sm block">${item.address}</span>
                                    <span class="text-white/30 text-xs">
                                        ${new Date(item.timestamp).toLocaleTimeString('ru-RU', {hour: '2-digit', minute:'2-digit'})}
                                    </span>
                                </div>
                                <button onclick='addHistoryToRoute(${JSON.stringify(item).replace(/'/g, "&#39;")})' class="bg-green-500/20 hover:bg-green-500 hover:text-white text-green-400 p-1.5 rounded-lg transition-all opacity-0 group-hover:opacity-100" title="–î–æ–±–∞–≤–∏—Ç—å –≤ –º–∞—Ä—à—Ä—É—Ç">
                                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"></path></svg>
                                </button>
                            </div>
                        `).join('')}
                    </div>
                </div>
            `).join('');
        }

        function addHistoryToRoute(item) {
            if (addresses.find(a => a.address.toLowerCase() === item.address.toLowerCase())) {
                showToast('–ê–¥—Ä–µ—Å —É–∂–µ –≤ –º–∞—Ä—à—Ä—É—Ç–µ', 'warning');
                return;
            }
            const newAddr = { ...item, id: Date.now() };
            addresses.push(newAddr);
            updateAddressList();
            updateMap();
            saveData();
            showToast('–ê–¥—Ä–µ—Å –¥–æ–±–∞–≤–ª–µ–Ω –∏–∑ –∏—Å—Ç–æ—Ä–∏–∏', 'success');
            if (historyLayer) {
                historyLayer.eachLayer(layer => {
                    if (layer.getPopup().getContent().includes(item.address)) {
                        map.removeLayer(layer);
                    }
                });
            }
        }

        function addAllFromDate(date) {
            const items = addressHistory.filter(h => h.date === date);
            let addedCount = 0;
            items.forEach((item, i) => {
                if (!addresses.find(a => a.address.toLowerCase() === item.address.toLowerCase())) {
                    addresses.push({ ...item, id: Date.now() + i });
                    addedCount++;
                }
            });
            if (addedCount > 0) {
                updateAddressList();
                updateMap();
                saveData();
                showToast(`–î–æ–±–∞–≤–ª–µ–Ω–æ –∞–¥—Ä–µ—Å–æ–≤: ${addedCount}`, 'success');
                toggleHistoryModal();
            } else {
                showToast('–í—Å–µ –∞–¥—Ä–µ—Å–∞ –∑–∞ —ç—Ç—É –¥–∞—Ç—É —É–∂–µ –¥–æ–±–∞–≤–ª–µ–Ω—ã', 'info');
            }
        }

        function previewHistoryOnMap(date) {
            historyLayer.clearLayers();
            const items = addressHistory.filter(h => h.date === date);
            if (items.length === 0) return;
            const bounds = [];
            items.forEach(item => {
                if (item.lat && item.lng) {
                    const icon = L.divIcon({
                        html: 'H',
                        className: 'history-marker-icon',
                        iconSize: [24, 24],
                        iconAnchor: [12, 12]
                    });
                    const marker = L.marker([item.lat, item.lng], { icon: icon })
                        .addTo(historyLayer)
                        .bindPopup(`
                            <div class="text-center">
                                <div class="font-bold mb-1">${item.address}</div>
                                <div class="text-xs text-gray-500 mb-2">${date}</div>
                                <button onclick='addHistoryToRoute(${JSON.stringify(item).replace(/'/g, "&#39;")})' class="bg-orange-500 text-white px-3 py-1 rounded text-xs w-full">–î–æ–±–∞–≤–∏—Ç—å –≤ –º–∞—Ä—à—Ä—É—Ç</button>
                            </div>
                        `);
                    marker.on('click', () => marker.openPopup());
                    bounds.push([item.lat, item.lng]);
                }
            });
            if (bounds.length > 0) {
                map.fitBounds(bounds, { padding: [50, 50] });
            }
            document.getElementById('clearHistoryBtn').classList.remove('hidden');
            toggleHistoryModal();
            showToast(`–ü–æ–∫–∞–∑–∞–Ω–æ ${items.length} –∞–¥—Ä–µ—Å–æ–≤ –∏–∑ –∏—Å—Ç–æ—Ä–∏–∏`, 'info');
        }

        function clearHistoryPreview() {
            historyLayer.clearLayers();
            document.getElementById('clearHistoryBtn').classList.add('hidden');
            if (markers.length > 0) {
                const group = new L.featureGroup(markers);
                map.fitBounds(group.getBounds(), { padding: [30, 30] });
            }
        }

        // Load saved data
        document.addEventListener('DOMContentLoaded', () => {
            const savedHistory = localStorage.getItem('majorExpressHistory');
            if (savedHistory) {
                addressHistory = JSON.parse(savedHistory);
            }
            const saved = localStorage.getItem('majorExpressAddresses');
            if (saved) {
                addresses = JSON.parse(saved);
                updateAddressList();
            }
            const savedStart = localStorage.getItem('majorExpressStart');
            if (savedStart) {
                startPoint = JSON.parse(savedStart);
                document.getElementById('startAddress').value = startPoint.address;
                document.getElementById('startPointDisplay').textContent = `‚úì ${startPoint.address}`;
                document.getElementById('startPointDisplay').classList.remove('hidden');
            }
        });

        function saveData() {
            localStorage.setItem('majorExpressAddresses', JSON.stringify(addresses));
            if (startPoint) {
                localStorage.setItem('majorExpressStart', JSON.stringify(startPoint));
            }
        }

        // –ù–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è –∞–¥—Ä–µ—Å–∞ –¥–ª—è –ª—É—á—à–µ–≥–æ –ø–æ–∏—Å–∫–∞
        function normalizeAddress(address) {
            let normalized = address.trim();
            
            // –ü—Ä–∏–≤–æ–¥–∏–º –∫ –Ω–∏–∂–Ω–µ–º—É —Ä–µ–≥–∏—Å—Ç—Ä—É –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏
            let lower = normalized.toLowerCase();
            
            // –£–±–∏—Ä–∞–µ–º –ª–∏—à–Ω–∏–µ —Å–ª–æ–≤–∞
            lower = lower.replace(/^(—É–ª–∏—Ü–∞|—É–ª\.?|–ø—Ä–æ—Å–ø–µ–∫—Ç|–ø—Ä\.?|–ø—Ä-—Ç|–ø–µ—Ä–µ—É–ª–æ–∫|–ø–µ—Ä\.?|–±—É–ª—å–≤–∞—Ä|–±-—Ä|–±—É–ª\.?|—à–æ—Å—Å–µ|—à\.?|–ø—Ä–æ–µ–∑–¥|–ø—Ä-–¥|–Ω–∞–±–µ—Ä–µ–∂–Ω–∞—è|–Ω–∞–±\.?|–ø–ª–æ—â–∞–¥—å|–ø–ª\.?)\s+/i, '');
            
            // –¢–∏–ø–∏—á–Ω—ã–µ –∑–∞–º–µ–Ω—ã –¥–ª—è –≥–æ–ª–æ—Å–æ–≤–æ–≥–æ –≤–≤–æ–¥–∞
            const replacements = {
                '–¥–æ–º ': '–¥.',
                '–∫–æ—Ä–ø—É—Å ': '–∫.',
                '—Å—Ç—Ä–æ–µ–Ω–∏–µ ': '—Å—Ç—Ä.',
                '–∫–≤–∞—Ä—Ç–∏—Ä–∞ ': '–∫–≤.',
                ' —Ç–∏—Ä–µ ': '-',
                ' –¥—Ä–æ–±—å ': '/',
            };
            
            for (const [from, to] of Object.entries(replacements)) {
                lower = lower.replace(new RegExp(from, 'gi'), to);
            }
            
            // –ü–µ—Ä–≤–∞—è –±—É–∫–≤–∞ –∑–∞–≥–ª–∞–≤–Ω–∞—è
            normalized = lower.charAt(0).toUpperCase() + lower.slice(1);
            
            return normalized;
        }

        // –£–º–Ω–∞—è –≥–µ–Ω–µ—Ä–∞—Ü–∏—è –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤ –∞–¥—Ä–µ—Å–∞ –¥–ª—è —Å–ª–æ–∂–Ω–æ–π –Ω—É–º–µ—Ä–∞—Ü–∏–∏ (14–î, 14–∫1 –∏ —Ç.–¥.)
        function generateAddressVariants(address) {
            const variants = [];
            const normalized = normalizeAddress(address); // –ë–∞–∑–æ–≤–∞—è –æ—á–∏—Å—Ç–∫–∞
            
            // –•–µ–ª–ø–µ—Ä –¥–ª—è —Ç—Ä–∞–Ω—Å–ª–∏—Ç–µ—Ä–∞—Ü–∏–∏ –±—É–∫–≤—ã –¥–æ–º–∞ (14–î -> 14D)
            // OSM —á–∞—Å—Ç–æ —Ö—Ä–∞–Ω–∏—Ç –∏–Ω–¥–µ–∫—Å—ã –ª–∞—Ç–∏–Ω–∏—Ü–µ–π
            function transliterateHouseLetter(str) {
                const map = {'–∞':'a', '–±':'b', '–≤':'v', '–≥':'g', '–¥':'d', '–µ':'e', '–∂':'zh', '–∑':'z', '–∏':'i', '–∫':'k', '–ª':'l', '–º':'m', '–Ω':'n', '–æ':'o', '–ø':'p', '—Ä':'r', '—Å':'s', '—Ç':'t', '—É':'u', '—Ñ':'f', '—Ö':'h', '—Ü':'c', '—á':'ch', '—à':'sh', '—â':'shch', '—ç':'e', '—é':'yu', '—è':'ya'};
                return str.replace(/(\d+)([–∞-—è])/ig, (match, num, letter) => {
                    const lat = map[letter.toLowerCase()];
                    return lat ? `${num}${lat.toUpperCase()}` : match;
                });
            }

            // –ë–∞–∑–æ–≤—ã–µ –≤–∞—Ä–∏–∞–Ω—Ç—ã
            const bases = [normalized];

            // 1. –ï—Å–ª–∏ –µ—Å—Ç—å —Å–ª–∏—Ç–∞—è –±—É–∫–≤–∞ (14–î), –ø—Ä–æ–±—É–µ–º –¥–æ–±–∞–≤–∏—Ç—å –ø—Ä–æ–±–µ–ª (14 –î)
            if (/(\d+)([–∞-—è–ê-–Ø])/i.test(normalized)) {
                bases.push(normalized.replace(/(\d+)([–∞-—è–ê-–Ø])/i, '$1 $2'));
            }

            // 2. –ü—Ä–æ–±—É–µ–º —Ç—Ä–∞–Ω—Å–ª–∏—Ç–µ—Ä–∞—Ü–∏—é –±—É–∫–≤—ã (14–î -> 14D)
            const trans = transliterateHouseLetter(normalized);
            if (trans !== normalized) {
                bases.push(trans);
            }

            // 3. –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–æ—Ä–ø—É—Å–æ–≤/—Å—Ç—Ä–æ–µ–Ω–∏–π
            // Expand "–∫" -> "–∫–æ—Ä–ø—É—Å"
            if (/(\d+)\s*–∫(–æ—Ä–ø)?\.?\s*(\d+)/i.test(normalized)) {
                bases.push(normalized.replace(/(\d+)\s*–∫(–æ—Ä–ø)?\.?\s*(\d+)/i, '$1 –∫–æ—Ä–ø—É—Å $3'));
            }
            // Expand "—Å" -> "—Å—Ç—Ä–æ–µ–Ω–∏–µ"
            if (/(\d+)\s*—Å(—Ç—Ä)?\.?\s*(\d+)/i.test(normalized)) {
                bases.push(normalized.replace(/(\d+)\s*—Å(—Ç—Ä)?\.?\s*(\d+)/i, '$1 —Å—Ç—Ä–æ–µ–Ω–∏–µ $3'));
            }
            // Expand both if present (e.g. 61–∫4—Å5 -> 61 –∫–æ—Ä–ø—É—Å 4 —Å—Ç—Ä–æ–µ–Ω–∏–µ 5)
            if (/(\d+)\s*–∫\s*(\d+)\s*—Å\s*(\d+)/i.test(normalized)) {
                bases.push(normalized.replace(/(\d+)\s*–∫\s*(\d+)\s*—Å\s*(\d+)/i, '$1 –∫–æ—Ä–ø—É—Å $2 —Å—Ç—Ä–æ–µ–Ω–∏–µ $3'));
            }

            // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –ø–æ–ª–Ω—ã–µ –∑–∞–ø—Ä–æ—Å—ã –¥–ª—è –≤—Å–µ—Ö –±–∞–∑
            bases.forEach(base => {
                // –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç: –ú–æ—Å–∫–≤–∞
                variants.push(`–ú–æ—Å–∫–≤–∞, ${base}`);
                variants.push(`Moscow, ${base}`); // –ò–Ω–æ–≥–¥–∞ –Ω–∞ –∞–Ω–≥–ª–∏–π—Å–∫–æ–º –∏—â–µ—Ç –ª—É—á—à–µ
                
                // –ï—Å–ª–∏ –Ω–µ —É–∫–∞–∑–∞–Ω —Ç–∏–ø —É–ª–∏—Ü—ã, –ø—Ä–æ–±—É–µ–º –ø–æ–¥—Å—Ç–∞–≤–∏—Ç—å
                if (!/(—É–ª–∏—Ü–∞|—É–ª\.|–ø—Ä–æ—Å–ø–µ–∫—Ç|–ø—Ä\.|–ø–µ—Ä–µ—É–ª–æ–∫|–ø–µ—Ä\.|–±—É–ª—å–≤–∞—Ä|—à–æ—Å—Å–µ|–ø—Ä–æ–µ–∑–¥|–Ω–∞–±–µ—Ä–µ–∂–Ω–∞—è|–ø–ª–æ—â–∞–¥—å|–±—É–ª\.|—à\.)/i.test(base)) {
                    variants.push(`–ú–æ—Å–∫–≤–∞, —É–ª–∏—Ü–∞ ${base}`);
                    variants.push(`–ú–æ—Å–∫–≤–∞, –ø—Ä–æ–µ–∑–¥ ${base}`);
                }
            });
            
            // Fallback: –ø—Ä–æ–±—É–µ–º –Ω–∞–π—Ç–∏ —Ö–æ—Ç—è –±—ã –Ω–æ–º–µ—Ä –¥–æ–º–∞ –±–µ–∑ –±—É–∫–≤—ã, –µ—Å–ª–∏ –Ω–∏—á–µ–≥–æ –Ω–µ –≤—ã—à–ª–æ
            // (–î–æ–±–∞–≤–ª—è–µ—Ç—Å—è –≤ –∫–æ–Ω–µ—Ü —Å–ø–∏—Å–∫–∞)
            const houseMatch = normalized.match(/(.*?\d+)[–∞-—è–ê-–Øa-zA-Z]/i);
            if (houseMatch) {
                variants.push(`–ú–æ—Å–∫–≤–∞, ${houseMatch[1]}`);
            }

            return [...new Set(variants)]; // –£–±–∏—Ä–∞–µ–º –¥—É–±–ª–∏–∫–∞—Ç—ã
        }

        async function geocodeAddress(address) {
            const variants = generateAddressVariants(address);
            
            // –ü—Ä–æ–±—É–µ–º Nominatim —Å —Ä–∞–∑–Ω—ã–º–∏ –≤–∞—Ä–∏–∞–Ω—Ç–∞–º–∏ –∞–¥—Ä–µ—Å–∞
            for (const variant of variants) {
                const result = await tryNominatim(variant);
                if (result) {
                    console.log(`‚úì –ù–∞–π–¥–µ–Ω –∞–¥—Ä–µ—Å: "${variant}"`);
                    return result;
                }
                // –ù–µ–±–æ–ª—å—à–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞ –º–µ–∂–¥—É –∑–∞–ø—Ä–æ—Å–∞–º–∏
                await new Promise(r => setTimeout(r, 300));
            }
            
            // –ï—Å–ª–∏ –Ω–µ –Ω–∞—à–ª–∏ - –ø—Ä–æ–±—É–µ–º Photon (–∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–π –≥–µ–æ–∫–æ–¥–µ—Ä –Ω–∞ –æ—Å–Ω–æ–≤–µ OSM)
            const photonResult = await tryPhoton(address);
            if (photonResult) {
                console.log(`‚úì –ù–∞–π–¥–µ–Ω —á–µ—Ä–µ–∑ Photon: "${address}"`);
                return photonResult;
            }
            
            console.log(`‚úó –ê–¥—Ä–µ—Å –Ω–µ –Ω–∞–π–¥–µ–Ω: "${address}"`);
            return null;
        }

        async function tryNominatim(fullAddress) {
            const url = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(fullAddress)}&limit=5&addressdetails=1&countrycodes=ru`;
            
            try {
                const response = await fetch(url, {
                    headers: { 'User-Agent': 'MajorExpressRouteOptimizer/1.0' }
                });
                const data = await response.json();
                
                if (data && data.length > 0) {
                    // –ò—â–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç –≤ –ú–æ—Å–∫–≤–µ
                    const moscowResult = data.find(item => {
                        const addr = item.address || {};
                        return addr.city === '–ú–æ—Å–∫–≤–∞' || 
                               addr.state === '–ú–æ—Å–∫–≤–∞' || 
                               (item.display_name && item.display_name.includes('–ú–æ—Å–∫–≤–∞'));
                    });
                    
                    const result = moscowResult || data[0];
                    
                    return {
                        lat: parseFloat(result.lat),
                        lng: parseFloat(result.lon),
                        displayName: result.display_name
                    };
                }
                return null;
            } catch (error) {
                console.error('Nominatim error:', error);
                return null;
            }
        }

        async function tryPhoton(address) {
            const fullAddress = `${address}, –ú–æ—Å–∫–≤–∞, –†–æ—Å—Å–∏—è`;
            const url = `https://photon.komoot.io/api/?q=${encodeURIComponent(fullAddress)}&limit=5&lang=ru`;
            
            try {
                const response = await fetch(url);
                const data = await response.json();
                
                if (data && data.features && data.features.length > 0) {
                    // –ò—â–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç –≤ –ú–æ—Å–∫–≤–µ
                    const moscowResult = data.features.find(f => {
                        const props = f.properties || {};
                        return props.city === '–ú–æ—Å–∫–≤–∞' || 
                               props.state === '–ú–æ—Å–∫–≤–∞' ||
                               (props.country === '–†–æ—Å—Å–∏—è' && props.name);
                    });
                    
                    const result = moscowResult || data.features[0];
                    const coords = result.geometry.coordinates;
                    
                    return {
                        lat: coords[1],
                        lng: coords[0],
                        displayName: result.properties.name || address
                    };
                }
                return null;
            } catch (error) {
                console.error('Photon error:', error);
                return null;
            }
        }

        async function setStartPoint() {
            const address = document.getElementById('startAddress').value.trim();
            if (!address) return;

            showLoading('–û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –Ω–∞—á–∞–ª—å–Ω–æ–π —Ç–æ—á–∫–∏...');
            const coords = await geocodeAddress(address);
            hideLoading();

            if (coords) {
                startPoint = { address, ...coords };
                document.getElementById('startPointDisplay').textContent = `‚úì ${address}`;
                document.getElementById('startPointDisplay').classList.remove('hidden');
                saveData();
                updateMap();
            } else {
                alert('–ù–µ —É–¥–∞–ª–æ—Å—å –Ω–∞–π—Ç–∏ –∞–¥—Ä–µ—Å. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —É—Ç–æ—á–Ω–∏—Ç—å.');
            }
        }

        async function addAddress() {
            const input = document.getElementById('addressInput');
            const timeInput = document.getElementById('timeInput');
            const address = input.value.trim();
            const time = timeInput.value; // Get time value
            
            if (!address) return;

            if (addresses.find(a => a.address.toLowerCase() === address.toLowerCase())) {
                showToast('–≠—Ç–æ—Ç –∞–¥—Ä–µ—Å —É–∂–µ –µ—Å—Ç—å –≤ –º–∞—Ä—à—Ä—É—Ç–µ', 'warning');
                return;
            }

            showLoading('–ü–æ–∏—Å–∫ –∞–¥—Ä–µ—Å–∞...');
            const coords = await geocodeAddress(address);
            hideLoading();

            if (coords) {
                const lastVisit = checkHistory(address);
                if (lastVisit) {
                    showToast(`–í—ã –±—ã–ª–∏ –∑–¥–µ—Å—å ${lastVisit}`, 'info');
                }

                const newAddr = { address, ...coords, time, id: Date.now() }; // Save time
                addresses.push(newAddr);
                addToHistory(newAddr);
                
                input.value = '';
                timeInput.value = ''; // Clear time input
                updateAddressList();
                updateMap();
                saveData();
            } else {
                showToast('–ù–µ —É–¥–∞–ª–æ—Å—å –Ω–∞–π—Ç–∏ –∞–¥—Ä–µ—Å', 'warning');
            }
        }

        // Dictionary for number words
        const NUMBER_WORDS = {
            '–æ–¥–∏–Ω': 1, '–æ–¥–Ω–∞': 1, '–æ–¥–Ω–æ': 1, '–ø–µ—Ä–≤—ã–π': 1, '1-–π': 1,
            '–¥–≤–∞': 2, '–¥–≤–µ': 2, '–≤—Ç–æ—Ä–æ–π': 2, '2-–π': 2,
            '—Ç—Ä–∏': 3, '—Ç—Ä–µ—Ç–∏–π': 3, '3-–π': 3,
            '—á–µ—Ç—ã—Ä–µ': 4, '—á–µ—Ç–≤–µ—Ä—Ç—ã–π': 4, '4-–π': 4,
            '–ø—è—Ç—å': 5, '–ø—è—Ç—ã–π': 5, '5-–π': 5,
            '—à–µ—Å—Ç—å': 6, '—à–µ—Å—Ç–æ–π': 6, '6-–π': 6,
            '—Å–µ–º—å': 7, '—Å–µ–¥—å–º–æ–π': 7, '7-–π': 7,
            '–≤–æ—Å–µ–º—å': 8, '–≤–æ—Å—å–º–æ–π': 8, '8-–π': 8,
            '–¥–µ–≤—è—Ç—å': 9, '–¥–µ–≤—è—Ç—ã–π': 9, '9-–π': 9,
            '–¥–µ—Å—è—Ç—å': 10, '–¥–µ—Å—è—Ç—ã–π': 10,
            '–æ–¥–∏–Ω–Ω–∞–¥—Ü–∞—Ç—å': 11, '–¥–≤–µ–Ω–∞–¥—Ü–∞—Ç—å': 12, '—Ç—Ä–∏–Ω–∞–¥—Ü–∞—Ç—å': 13, '—á–µ—Ç—ã—Ä–Ω–∞–¥—Ü–∞—Ç—å': 14, '–ø—è—Ç–Ω–∞–¥—Ü–∞—Ç—å': 15,
            '—à–µ—Å—Ç–Ω–∞–¥—Ü–∞—Ç—å': 16, '—Å–µ–º–Ω–∞–¥—Ü–∞—Ç—å': 17, '–≤–æ—Å–µ–º–Ω–∞–¥—Ü–∞—Ç—å': 18, '–¥–µ–≤—è—Ç–Ω–∞–¥—Ü–∞—Ç—å': 19,
            '–¥–≤–∞–¥—Ü–∞—Ç—å': 20, '—Ç—Ä–∏–¥—Ü–∞—Ç—å': 30, '—Å–æ—Ä–æ–∫': 40, '–ø—è—Ç—å–¥–µ—Å—è—Ç': 50, '—à–µ—Å—Ç—å–¥–µ—Å—è—Ç': 60, '—Å–µ–º—å–¥–µ—Å—è—Ç': 70, '–≤–æ—Å–µ–º—å–¥–µ—Å—è—Ç': 80, '–¥–µ–≤—è–Ω–æ—Å—Ç–æ': 90,
            '—Å—Ç–æ': 100
        };

        function replaceNumberWords(text) {
            let processed = text.toLowerCase();
            
            // 1. Number words to digits
            for (const [word, num] of Object.entries(NUMBER_WORDS)) {
                const regex = new RegExp(`(^|\\s)${word}(?=$|[\\s.,])`, 'gi');
                processed = processed.replace(regex, `$1${num}`);
            }
            
            // 2. Combine compound numbers (twenty five -> 25)
            processed = processed.replace(/(\d+)\s+(\d+)/g, (match, n1, n2) => {
                if (['20','30','40','50','60','70','80','90'].includes(n1) && n2.length === 1) {
                    return parseInt(n1) + parseInt(n2);
                }
                return match;
            });

            // 3. Address abbreviations
            // Remove "–¥–æ–º"
            processed = processed.replace(/(\s|^)–¥–æ–º\s*(\d+)/gi, '$1$2');
            
            // Replace "–∫–æ—Ä–ø—É—Å", "—Å—Ç—Ä–æ–µ–Ω–∏–µ" with "–∫" and "—Å"
            processed = processed.replace(/(\s|^)–∫–æ—Ä–ø—É—Å(\s|$)/gi, '$1–∫$2');
            processed = processed.replace(/(\s|^)–∫–æ—Ä–ø(\.?\s|$)/gi, '$1–∫$2');
            processed = processed.replace(/(\s|^)—Å—Ç—Ä–æ–µ–Ω–∏–µ(\s|$)/gi, '$1—Å$2');
            processed = processed.replace(/(\s|^)—Å—Ç—Ä(\.?\s|$)/gi, '$1—Å$2');
            
            // Collapse spaces between number and k/s (e.g. "14 –∫ 4" -> "14–∫4")
            // Handle house number + corpus
            processed = processed.replace(/(\d+)\s*–∫\s*(\d+)/gi, '$1–∫$2');
            // Handle corpus + structure (e.g. "14–∫4 —Å 5" -> "14–∫4—Å5")
            processed = processed.replace(/(\d+)\s*—Å\s*(\d+)/gi, '$1—Å$2');
            // Handle "14 —Å—Ç—Ä–æ–µ–Ω–∏–µ 5" directly (which became "14 —Å 5")
            processed = processed.replace(/(\d+)\s*—Å(—Ç—Ä)?\s*(\d+)/gi, '$1—Å$3');

            // Clean up double spaces
            processed = processed.replace(/\s+/g, ' ').trim();

            return processed;
        }

        function extractTimeFromSpeech(text) {
            // Match "–∫ 15:30", "–≤ 12", "–¥–æ 14 00" etc.
            const timeRegex = /(?:–∫|–≤|–¥–æ|–Ω–∞)\s+(\d{1,2})(?:[:\s](\d{2}))?(?:\s*—á(?:–∞—Å–æ–≤)?)?/i;
            const match = text.match(timeRegex);
            
            if (match) {
                let hours = parseInt(match[1]);
                let minutes = match[2] ? parseInt(match[2]) : 0;
                
                // Basic validation
                if (hours >= 0 && hours < 24 && minutes >= 0 && minutes < 60) {
                    // Format as HH:MM
                    const timeStr = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
                    
                    // Remove the time part from the address string
                    const cleanAddress = text.replace(match[0], '').trim();
                    return { time: timeStr, address: cleanAddress };
                }
            }
            return { time: null, address: text };
        }

        async function addBulkAddresses() {
            const textarea = document.getElementById('bulkAddresses');
            const lines = textarea.value.split('\n').map(l => l.trim()).filter(l => l);
            
            if (lines.length === 0) return;

            showLoading(`–û–±—Ä–∞–±–æ—Ç–∫–∞ –∞–¥—Ä–µ—Å–æ–≤: 0/${lines.length}`);
            
            for (let i = 0; i < lines.length; i++) {
                document.getElementById('loadingText').textContent = `–û–±—Ä–∞–±–æ—Ç–∫–∞ –∞–¥—Ä–µ—Å–æ–≤: ${i + 1}/${lines.length}`;
                
                const address = lines[i];
                if (addresses.find(a => a.address.toLowerCase() === address.toLowerCase())) {
                    continue;
                }

                const coords = await geocodeAddress(address);
                if (coords) {
                    const lastVisit = checkHistory(address);
                    if (lastVisit) {
                        // Delay toasts slightly so they don't stack instantly
                        setTimeout(() => showToast(`–í—ã –±—ã–ª–∏ –∑–¥–µ—Å—å ${lastVisit} (${address})`, 'info'), i * 500);
                    }

                    const newAddr = { address, ...coords, id: Date.now() + i };
                    addresses.push(newAddr);
                    addToHistory(newAddr);
                }
                
                // Small delay to avoid rate limiting
                await new Promise(r => setTimeout(r, 1000));
            }

            hideLoading();
            textarea.value = '';
            updateAddressList();
            updateMap();
            saveData();
        }

        function removeAddress(id) {
            addresses = addresses.filter(a => a.id !== id);
            updateAddressList();
            updateMap();
            saveData();
        }

        function clearAllAddresses() {
            if (confirm('–£–¥–∞–ª–∏—Ç—å –≤—Å–µ –∞–¥—Ä–µ—Å–∞?')) {
                addresses = [];
                updateAddressList();
                updateMap();
                saveData();
            }
        }

        function updateAddressTime(id, newTime) {
            const addr = addresses.find(a => a.id === id);
            if (addr) {
                addr.time = newTime;
                saveData();
                updateMap();
            }
        }

        function toggleAddressStatus(id) {
            const addr = addresses.find(a => a.id === id);
            if (addr) {
                addr.completed = !addr.completed;
                saveData();
                updateAddressList();
                updateMap();
            }
        }

        function updateAddressNotes(id, notes) {
            const addr = addresses.find(a => a.id === id);
            if (addr) {
                addr.notes = notes;
                saveData();
            }
        }

        function updateStats() {
            const total = addresses.length;
            const completed = addresses.filter(a => a.completed).length;
            const remaining = total - completed;
            const percent = total === 0 ? 0 : Math.round((completed / total) * 100);

            const statCompleted = document.getElementById('statCompleted');
            const statTotal = document.getElementById('statTotal');
            const statRemaining = document.getElementById('statRemaining');
            const statPercent = document.getElementById('statPercent');
            const statBar = document.getElementById('statBar');
            const statDistance = document.getElementById('statDistance');

            if (statCompleted) statCompleted.textContent = completed;
            if (statTotal) statTotal.textContent = total;
            if (statRemaining) statRemaining.textContent = remaining;
            if (statPercent) statPercent.textContent = `${percent}%`;
            if (statBar) statBar.style.width = `${percent}%`;
            
            // Update distance if element exists
            const distElem = document.getElementById('totalDistance');
            if (statDistance && distElem) {
                statDistance.textContent = distElem.textContent || '0 –∫–º';
            }
        }

        function updateAddressList() {
            updateStats();
            const list = document.getElementById('addressList');
            document.getElementById('addressCount').textContent = addresses.length;

            if (addresses.length === 0) {
                list.innerHTML = '<p class="text-white/50 text-center py-4">–ê–¥—Ä–µ—Å–∞ –ø–æ–∫–∞ –Ω–µ –¥–æ–±–∞–≤–ª–µ–Ω—ã</p>';
                return;
            }

            list.innerHTML = addresses.map((addr, index) => `
                <div class="address-item flex flex-col gap-2 bg-white/5 rounded-xl px-4 py-3 cursor-move hover:bg-white/10 ${addr.completed ? 'address-completed' : ''}" 
                     draggable="true" data-id="${addr.id}">
                    <div class="flex items-start gap-3">
                        <div class="drag-handle text-white/30 hover:text-white cursor-grab active:cursor-grabbing p-1 pt-2">
                            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 8h16M4 16h16"></path></svg>
                        </div>
                        
                        <button onclick="toggleAddressStatus(${addr.id})" class="flex-shrink-0 w-7 h-7 ${addr.completed ? 'bg-green-500 hover:bg-green-600' : 'bg-blue-500 hover:bg-blue-600'} rounded-full flex items-center justify-center text-white text-sm font-bold transition-colors mt-0.5">
                            ${addr.completed ? '<svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path></svg>' : (index + 1)}
                        </button>

                        <div class="flex-1 min-w-0">
                            <div class="text-white text-sm truncate mb-1.5 ${addr.completed ? 'line-through text-white/50' : ''}" title="${addr.address}">${addr.address}</div>
                            
                            <div class="flex items-center gap-2 flex-wrap">
                                <div class="relative flex items-center group">
                                    <svg class="w-3 h-3 text-white/40 absolute left-2 pointer-events-none group-focus-within:text-orange-400 transition-colors" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
                                    <input type="time" 
                                        value="${addr.time || ''}" 
                                        onchange="updateAddressTime(${addr.id}, this.value)"
                                        class="bg-black/20 border border-white/10 rounded-lg pl-7 pr-1 py-1 text-xs text-white/80 focus:outline-none focus:bg-black/40 focus:border-orange-500/50 focus:text-white transition-all w-24 cursor-pointer"
                                        title="–í—Ä–µ–º—è –ø—Ä–∏–±—ã—Ç–∏—è">
                                </div>
                            </div>
                        </div>

                        <button onclick="removeAddress(${addr.id})" class="text-red-400 hover:text-red-300 flex-shrink-0 p-2 rounded-lg hover:bg-white/5 transition-colors" title="–£–¥–∞–ª–∏—Ç—å">
                            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                        </button>
                    </div>
                    
                    <div class="pl-10">
                        <input type="text" 
                            placeholder="–ó–∞–º–µ—Ç–∫–∏ (–∫–æ–¥, —ç—Ç–∞–∂, —Ç–µ–ª–µ—Ñ–æ–Ω...)" 
                            value="${addr.notes || ''}"
                            onchange="updateAddressNotes(${addr.id}, this.value)"
                            class="notes-input w-full bg-black/10 border border-white/5 rounded-lg px-3 py-1.5 text-xs text-white/70 placeholder-white/20 focus:outline-none focus:border-blue-500/50 focus:text-white">
                    </div>
                </div>
            `).join('');

            // Add drag listeners
            const items = list.querySelectorAll('.address-item');
            items.forEach(item => {
                item.addEventListener('dragstart', handleDragStart);
                item.addEventListener('dragover', handleDragOver);
                item.addEventListener('drop', handleDrop);
            });
        }

        function updateMap() {
            // Clear existing markers and route
            markers.forEach(m => map.removeLayer(m));
            markers = [];
            if (routeLine) {
                map.removeLayer(routeLine);
                routeLine = null;
            }

            const bounds = [];

            // Add start point marker
            if (startPoint && startPoint.lat) {
                const startIcon = L.divIcon({
                    html: '<div class="w-8 h-8 bg-green-500 rounded-full flex items-center justify-center text-white font-bold shadow-lg border-2 border-white">–ê</div>',
                    className: 'custom-marker',
                    iconSize: [32, 32],
                    iconAnchor: [16, 16]
                });
                const marker = L.marker([startPoint.lat, startPoint.lng], { icon: startIcon })
                    .addTo(map)
                    .bindPopup(`<b>–°—Ç–∞—Ä—Ç:</b> ${startPoint.address}`);
                markers.push(marker);
                bounds.push([startPoint.lat, startPoint.lng]);
            }

            // Add address markers
            addresses.forEach((addr, index) => {
                if (addr.lat && addr.lng) {
                    const bgClass = addr.completed ? 'bg-gray-500' : 'bg-blue-500';
                    const icon = L.divIcon({
                        html: `<div class="w-7 h-7 ${bgClass} rounded-full flex items-center justify-center text-white text-sm font-bold shadow-lg border-2 border-white">${index + 1}</div>`,
                        className: 'custom-marker',
                        iconSize: [28, 28],
                        iconAnchor: [14, 14]
                    });
                    const marker = L.marker([addr.lat, addr.lng], { icon: icon })
                        .addTo(map)
                        .bindPopup(`
                            <b>${index + 1}.</b> ${addr.address}
                            ${addr.time ? `<br><span class="text-green-600 font-bold">üïí –∫ ${addr.time}</span>` : ''}
                            ${addr.notes ? `<br><span class="text-gray-600 text-xs">üìù ${addr.notes}</span>` : ''}
                        `);
                    
                    if (addr.completed) {
                        marker.setOpacity(0.6);
                    }
                    
                    markers.push(marker);
                    bounds.push([addr.lat, addr.lng]);
                }
            });

            // Fit bounds
            if (bounds.length > 0) {
                map.fitBounds(bounds, { padding: [30, 30] });
            }
        }

        // Calculate distance between two points (Haversine formula)
        function calculateDistance(lat1, lng1, lat2, lng2) {
            const R = 6371; // Earth's radius in km
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLng = (lng2 - lng1) * Math.PI / 180;
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                      Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                      Math.sin(dLng/2) * Math.sin(dLng/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
        }

        // Helper: Convert HH:MM to minutes from midnight
        function getMinutes(timeStr) {
            if (!timeStr) return null;
            const [h, m] = timeStr.split(':').map(Number);
            return h * 60 + m;
        }

        // NEW Smart Algorithm: Prioritizes filling time gaps before timed events
        function optimizeRouteAlgorithm(points, start) {
            if (points.length === 0) return [];
            
            // 1. Timed points create the chronological backbone
            let timedPoints = points.filter(p => p.time).sort((a, b) => {
                return getMinutes(a.time) - getMinutes(b.time);
            });
            let untimedPoints = points.filter(p => !p.time);
            
            if (timedPoints.length === 0) {
                return solveNearestNeighbor(points, start);
            }

            // Start backbone: [Start] -> [T1] -> [T2] ...
            // The 'route' array holds the actual delivery points in order.
            // We will insert untimed points into this array.
            let route = [...timedPoints];

            // Assume morning start at 8:00 (480 min) if no current time logic
            const START_TIME_MINUTES = 8 * 60; 

            // Greedy Insertion Strategy
            while (untimedPoints.length > 0) {
                let bestPointIdx = -1;
                let bestInsertIdx = -1; 
                let minInsertionCost = Infinity;

                for (let i = 0; i < untimedPoints.length; i++) {
                    const p = untimedPoints[i];
                    
                    // Try inserting 'p' into every slot 'k'
                    // Slot k=0 is before route[0]
                    // Slot k=N is after route[N-1]
                    for (let k = 0; k <= route.length; k++) {
                        let A = (k === 0) ? start : route[k-1];
                        let B = (k === route.length) ? null : route[k];
                        
                        // 1. Physical Detour Cost
                        let detour = 0;
                        if (B) {
                            const dAB = calculateDistance(A.lat, A.lng, B.lat, B.lng);
                            const dAP = calculateDistance(A.lat, A.lng, p.lat, p.lng);
                            const dPB = calculateDistance(p.lat, p.lng, B.lat, B.lng);
                            detour = dAP + dPB - dAB;
                        } else {
                            detour = calculateDistance(A.lat, A.lng, p.lat, p.lng);
                        }

                        // 2. "Gap Filling" Reward
                        // If we insert BEFORE a timed point B, we reduce the "useless wait" at B.
                        // We want to prioritize this MASSIVELY.
                        
                        let gapReward = 0;
                        if (B && B.time) {
                            // We are inserting into a slot that ends with a fixed time commitment.
                            // Every km we add here is effectively "free" in terms of time (up to a limit),
                            // because we would just be waiting at B anyway.
                            
                            // Base reward for picking a "pre-timed" slot
                            gapReward = 100; 
                            
                            // Distance heuristic: If p is relatively close to A, it's a perfect filler.
                            const dAP = calculateDistance(A.lat, A.lng, p.lat, p.lng);
                            if (dAP < 5) gapReward += 20; // Bonus for nearby fillers
                        }

                        // Total Cost = Detour - Reward
                        // A high reward makes cost negative, encouraging insertion.
                        let totalCost = detour - gapReward;

                        if (totalCost < minInsertionCost) {
                            minInsertionCost = totalCost;
                            bestPointIdx = i;
                            bestInsertIdx = k;
                        }
                    }
                }

                const pointToInsert = untimedPoints[bestPointIdx];
                route.splice(bestInsertIdx, 0, pointToInsert);
                untimedPoints.splice(bestPointIdx, 1);
            }

            return route;
        }

        // Drag & Drop Handlers
        let draggedItem = null;

        function handleDragStart(e) {
            draggedItem = this;
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/html', this.innerHTML);
            this.classList.add('opacity-50');
        }

        function handleDragOver(e) {
            if (e.preventDefault) e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
            return false;
        }

        function handleDrop(e) {
            if (e.stopPropagation) e.stopPropagation();
            
            if (draggedItem !== this) {
                // Get IDs from the elements
                const fromId = Number(draggedItem.getAttribute('data-id'));
                const toId = Number(this.getAttribute('data-id'));
                
                // Reorder array
                const fromIndex = addresses.findIndex(a => a.id === fromId);
                const toIndex = addresses.findIndex(a => a.id === toId);
                
                if (fromIndex > -1 && toIndex > -1) {
                    const [movedItem] = addresses.splice(fromIndex, 1);
                    addresses.splice(toIndex, 0, movedItem);
                    
                    saveData();
                    updateAddressList();
                    
                    // Redraw route without re-optimizing (keep user order)
                    drawRouteManually();
                }
            }
            draggedItem.classList.remove('opacity-50');
            return false;
        }

        function drawRouteManually() {
             // Calculate total distance
            let totalDistance = 0;
            let prevPoint = startPoint;
            
            addresses.forEach(addr => {
                totalDistance += calculateDistance(prevPoint.lat, prevPoint.lng, addr.lat, addr.lng);
                prevPoint = addr;
            });

            if (routeLine) {
                map.removeLayer(routeLine);
            }

            const routePoints = [
                [startPoint.lat, startPoint.lng],
                ...addresses.map(a => [a.lat, a.lng])
            ];

            routeLine = L.polyline(routePoints, {
                color: '#f97316',
                weight: 4,
                opacity: 0.8,
                dashArray: '10, 10'
            }).addTo(map);

            updateMap();

            // Update stats
            document.getElementById('totalDistance').textContent = `${totalDistance.toFixed(1)} –∫–º`;
        }

        function solveNearestNeighbor(points, start) {
            const optimized = [];
            const remaining = [...points];
            let current = start;

            while (remaining.length > 0) {
                let nearestIndex = 0;
                let nearestDist = Infinity;

                for (let i = 0; i < remaining.length; i++) {
                    const dist = calculateDistance(
                        current.lat, current.lng,
                        remaining[i].lat, remaining[i].lng
                    );
                    if (dist < nearestDist) {
                        nearestDist = dist;
                        nearestIndex = i;
                    }
                }

                optimized.push(remaining[nearestIndex]);
                current = remaining[nearestIndex];
                remaining.splice(nearestIndex, 1);
            }
            return optimized;
        }

        async function optimizeRoute() {
            if (addresses.length === 0) {
                alert('–î–æ–±–∞–≤—å—Ç–µ —Ö–æ—Ç—è –±—ã –æ–¥–∏–Ω –∞–¥—Ä–µ—Å');
                return;
            }

            if (!startPoint) {
                alert('–£–∫–∞–∂–∏—Ç–µ –Ω–∞—á–∞–ª—å–Ω—É—é —Ç–æ—á–∫—É –º–∞—Ä—à—Ä—É—Ç–∞');
                return;
            }

            showLoading('–û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –º–∞—Ä—à—Ä—É—Ç–∞...');

            // Small delay for UX
            await new Promise(r => setTimeout(r, 500));

            const optimizedAddresses = optimizeRouteAlgorithm(addresses, startPoint);
            
            // Update addresses array with optimized order
            addresses = optimizedAddresses;
            saveData();

            // Calculate total distance
            let totalDistance = 0;
            let prevPoint = startPoint;
            
            optimizedAddresses.forEach(addr => {
                totalDistance += calculateDistance(prevPoint.lat, prevPoint.lng, addr.lat, addr.lng);
                prevPoint = addr;
            });

            // Draw route line
            if (routeLine) {
                map.removeLayer(routeLine);
            }

            const routePoints = [
                [startPoint.lat, startPoint.lng],
                ...optimizedAddresses.map(a => [a.lat, a.lng])
            ];

            routeLine = L.polyline(routePoints, {
                color: '#f97316',
                weight: 4,
                opacity: 0.8,
                dashArray: '10, 10'
            }).addTo(map);

            // Update markers with new order
            updateMap();

            // Update optimized route display
            const routeDiv = document.getElementById('optimizedRoute');
            routeDiv.innerHTML = `
                <div class="flex items-center gap-3 bg-green-500/20 rounded-xl px-4 py-3 mb-2">
                    <span class="w-7 h-7 bg-green-500 rounded-full flex items-center justify-center text-white text-sm font-bold">–ê</span>
                    <span class="text-green-400 flex-1 text-sm">${startPoint.address}</span>
                    <span class="text-white/50 text-xs">–°–¢–ê–†–¢</span>
                </div>
                ${optimizedAddresses.map((addr, index) => `
                    <div class="flex items-center gap-3 bg-white/5 rounded-xl px-4 py-3">
                        <span class="w-7 h-7 bg-orange-500 rounded-full flex items-center justify-center text-white text-sm font-bold">${index + 1}</span>
                        <span class="text-white flex-1 text-sm truncate">${addr.address}</span>
                    </div>
                `).join('')}
            `;

            // Show stats
            document.getElementById('routeStats').classList.remove('hidden');
            document.getElementById('totalDistance').textContent = `${totalDistance.toFixed(1)} –∫–º`;
            // Estimate time: average speed in city 20 km/h + 5 min per stop
            const timeMinutes = Math.round((totalDistance / 20) * 60 + optimizedAddresses.length * 5);
            const hours = Math.floor(timeMinutes / 60);
            const mins = timeMinutes % 60;
            document.getElementById('totalTime').textContent = hours > 0 ? `${hours}—á ${mins}–º` : `${mins} –º–∏–Ω`;

            hideLoading();

            // Update address list with new order
            updateAddressList();
        }

        function openInYandexMaps() {
            if (!startPoint || addresses.length === 0) {
                alert('–°–Ω–∞—á–∞–ª–∞ –¥–æ–±–∞–≤—å—Ç–µ –∞–¥—Ä–µ—Å–∞ –∏ –ø–æ—Å—Ç—Ä–æ–π—Ç–µ –º–∞—Ä—à—Ä—É—Ç');
                return;
            }

            // Yandex Maps route URL
            let url = 'https://yandex.ru/maps/?rtext=';
            const points = [startPoint, ...addresses];
            url += points.map(p => `${p.lat},${p.lng}`).join('~');
            url += '&rtt=auto';
            
            window.open(url, '_blank');
        }

        function openInGoogleMaps() {
            if (!startPoint || addresses.length === 0) {
                alert('–°–Ω–∞—á–∞–ª–∞ –¥–æ–±–∞–≤—å—Ç–µ –∞–¥—Ä–µ—Å–∞ –∏ –ø–æ—Å—Ç—Ä–æ–π—Ç–µ –º–∞—Ä—à—Ä—É—Ç');
                return;
            }

            // Google Maps has a limit of waypoints, so we'll use the basic route
            let url = 'https://www.google.com/maps/dir/';
            const points = [startPoint, ...addresses];
            url += points.map(p => `${p.lat},${p.lng}`).join('/');
            
            window.open(url, '_blank');
        }

        function showLoading(text) {
            document.getElementById('loadingText').textContent = text;
            document.getElementById('loadingOverlay').classList.remove('hidden');
        }

        function hideLoading() {
            document.getElementById('loadingOverlay').classList.add('hidden');
        }

        // ==================== VOICE RECOGNITION ====================
        let recognition = null;
        let isRecording = false;
        let autoOptimizeEnabled = true;

        // Initialize Speech Recognition
        function initSpeechRecognition() {
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            
            if (!SpeechRecognition) {
                document.getElementById('voiceBtn').disabled = true;
                document.getElementById('voiceBtnText').textContent = '–ë—Ä–∞—É–∑–µ—Ä –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç –≥–æ–ª–æ—Å–æ–≤–æ–π –≤–≤–æ–¥';
                document.getElementById('voiceStatus').textContent = '–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ Chrome, Edge –∏–ª–∏ Safari';
                return;
            }

            recognition = new SpeechRecognition();
            recognition.lang = 'ru-RU';
            recognition.continuous = true;
            recognition.interimResults = true;
            recognition.maxAlternatives = 1;

            recognition.onstart = () => {
                isRecording = true;
                updateVoiceUI(true);
                document.getElementById('voiceStatus').textContent = '–°–ª—É—à–∞—é... –ì–æ–≤–æ—Ä–∏—Ç–µ –∞–¥—Ä–µ—Å';
            };

            recognition.onresult = async (event) => {
                let interimTranscript = '';
                let finalTranscript = '';

                for (let i = event.resultIndex; i < event.results.length; i++) {
                    const transcript = event.results[i][0].transcript;
                    if (event.results[i].isFinal) {
                        finalTranscript += transcript;
                    } else {
                        interimTranscript += transcript;
                    }
                }

                // Show what's being recognized
                const recognizedDiv = document.getElementById('recognizedText');
                const recognizedSpan = document.getElementById('recognizedAddress');
                
                if (interimTranscript) {
                    recognizedDiv.classList.remove('hidden');
                    recognizedSpan.textContent = interimTranscript;
                    recognizedSpan.classList.add('text-white/50');
                }

                if (finalTranscript) {
                    recognizedDiv.classList.remove('hidden');
                    recognizedSpan.textContent = finalTranscript;
                    recognizedSpan.classList.remove('text-white/50');
                    
                    // Process the recognized address
                    await processVoiceAddress(finalTranscript.trim());
                }
            };

            recognition.onerror = (event) => {
                console.error('Speech recognition error:', event.error);
                if (event.error === 'no-speech') {
                    document.getElementById('voiceStatus').textContent = '–ù–µ —Å–ª—ã—à—É —Ä–µ—á—å. –ì–æ–≤–æ—Ä–∏—Ç–µ –≥—Ä–æ–º—á–µ.';
                } else if (event.error === 'not-allowed') {
                    document.getElementById('voiceStatus').textContent = '–†–∞–∑—Ä–µ—à–∏—Ç–µ –¥–æ—Å—Ç—É–ø –∫ –º–∏–∫—Ä–æ—Ñ–æ–Ω—É';
                } else {
                    document.getElementById('voiceStatus').textContent = `–û—à–∏–±–∫–∞: ${event.error}`;
                }
            };

            recognition.onend = () => {
                // Auto-restart if still recording
                if (isRecording) {
                    try {
                        recognition.start();
                    } catch (e) {
                        isRecording = false;
                        updateVoiceUI(false);
                    }
                } else {
                    updateVoiceUI(false);
                }
            };
        }

        function updateVoiceUI(recording) {
            const btn = document.getElementById('voiceBtn');
            const text = document.getElementById('voiceBtnText');
            const icon = document.getElementById('micIcon');
            const wave = document.getElementById('voiceWave');

            if (recording) {
                btn.classList.add('recording');
                btn.classList.remove('from-red-500', 'to-red-600');
                btn.classList.add('from-red-600', 'to-red-700', 'bg-red-600');
                text.textContent = '–°–ª—É—à–∞—é...';
                icon.classList.add('hidden');
                wave.classList.remove('hidden');
            } else {
                btn.classList.remove('recording', 'from-red-600', 'to-red-700', 'bg-red-600');
                btn.classList.add('from-red-500', 'to-red-600');
                text.textContent = '–ù–∞–∂–º–∏—Ç–µ –∏ –≥–æ–≤–æ—Ä–∏—Ç–µ –∞–¥—Ä–µ—Å';
                icon.classList.remove('hidden');
                wave.classList.add('hidden');
                document.getElementById('voiceStatus').textContent = '–ì–æ–≤–æ—Ä–∏—Ç–µ –∞–¥—Ä–µ—Å–∞ –æ–¥–∏–Ω –∑–∞ –¥—Ä—É–≥–∏–º ‚Äî –æ–Ω–∏ –¥–æ–±–∞–≤—è—Ç—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏';
            }
        }

        function toggleVoiceRecording() {
            if (!recognition) {
                initSpeechRecognition();
                if (!recognition) return;
            }

            if (isRecording) {
                isRecording = false;
                recognition.stop();
                updateVoiceUI(false);
            } else {
                try {
                    recognition.start();
                } catch (e) {
                    console.error('Failed to start recognition:', e);
                }
            }
        }

        async function processVoiceAddress(rawText) {
            if (!rawText || rawText.length < 3) return;

            // 1. Convert number words to digits (Fix for "–∫–æ—Ä–ø—É—Å —á–µ—Ç—ã—Ä–µ")
            let textWithDigits = replaceNumberWords(rawText);

            // 2. Extract time
            const { time, address: cleanAddress } = extractTimeFromSpeech(textWithDigits);
            
            // Clean up the address
            let address = cleanAddress.charAt(0).toUpperCase() + cleanAddress.slice(1);
            
            // Check for duplicates
            if (addresses.find(a => a.address.toLowerCase() === address.toLowerCase())) {
                document.getElementById('voiceStatus').textContent = `"${address}" —É–∂–µ –¥–æ–±–∞–≤–ª–µ–Ω. –ì–æ–≤–æ—Ä–∏—Ç–µ —Å–ª–µ–¥—É—é—â–∏–π.`;
                showToast(`"${address}" —É–∂–µ –≤ —Å–ø–∏—Å–∫–µ`, 'warning');
                return;
            }

            document.getElementById('voiceStatus').textContent = `–ò—â—É: "${address}"...`;

            const coords = await geocodeAddress(address);

            if (coords) {
                const lastVisit = checkHistory(address);
                if (lastVisit) {
                    showToast(`–í—ã –±—ã–ª–∏ –∑–¥–µ—Å—å ${lastVisit}`, 'info');
                }

                const newAddr = { address, ...coords, time, id: Date.now() };
                addresses.push(newAddr);
                addToHistory(newAddr);
                
                updateAddressList();
                updateMap();
                saveData();

                // Show success
                const timeMsg = time ? `(–∫ ${time})` : '';
                document.getElementById('voiceStatus').innerHTML = `
                    <span class="text-green-400">‚úì –î–æ–±–∞–≤–ª–µ–Ω: "${address}" ${timeMsg}</span><br>
                    <span class="text-white/50">–ì–æ–≤–æ—Ä–∏—Ç–µ —Å–ª–µ–¥—É—é—â–∏–π –∞–¥—Ä–µ—Å...</span>
                `;

                // Auto optimize if we have start point
                if (autoOptimizeEnabled && startPoint && addresses.length >= 2) {
                    autoOptimizeRoute();
                }
            } else {
                document.getElementById('voiceStatus').innerHTML = `
                    <span class="text-red-400">‚úó –ù–µ –Ω–∞–π–¥–µ–Ω: "${address}"</span><br>
                    <span class="text-white/50">–ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–∫–∞–∑–∞—Ç—å —Ç–æ—á–Ω–µ–µ...</span>
                `;
            }
        }

        // Auto optimize without full UI update
        async function autoOptimizeRoute() {
            if (addresses.length < 2 || !startPoint) return;

            const optimizedAddresses = optimizeRouteAlgorithm(addresses, startPoint);
            addresses = optimizedAddresses;
            saveData();

            // Calculate total distance
            let totalDistance = 0;
            let prevPoint = startPoint;
            
            optimizedAddresses.forEach(addr => {
                totalDistance += calculateDistance(prevPoint.lat, prevPoint.lng, addr.lat, addr.lng);
                prevPoint = addr;
            });

            // Draw route line
            if (routeLine) {
                map.removeLayer(routeLine);
            }

            const routePoints = [
                [startPoint.lat, startPoint.lng],
                ...optimizedAddresses.map(a => [a.lat, a.lng])
            ];

            routeLine = L.polyline(routePoints, {
                color: '#f97316',
                weight: 4,
                opacity: 0.8,
                dashArray: '10, 10'
            }).addTo(map);

            // Update markers with new order
            updateMap();

            // Update optimized route display
            const routeDiv = document.getElementById('optimizedRoute');
            routeDiv.innerHTML = `
                <div class="flex items-center gap-3 bg-green-500/20 rounded-xl px-4 py-3 mb-2">
                    <span class="w-7 h-7 bg-green-500 rounded-full flex items-center justify-center text-white text-sm font-bold">–ê</span>
                    <span class="text-green-400 flex-1 text-sm">${startPoint.address}</span>
                    <span class="text-white/50 text-xs">–°–¢–ê–†–¢</span>
                </div>
                ${optimizedAddresses.map((addr, index) => `
                    <div class="flex items-center gap-3 bg-white/5 rounded-xl px-4 py-3">
                        <span class="w-7 h-7 bg-orange-500 rounded-full flex items-center justify-center text-white text-sm font-bold">${index + 1}</span>
                        <span class="text-white flex-1 text-sm truncate">${addr.address}</span>
                    </div>
                `).join('')}
            `;

            // Show stats
            document.getElementById('routeStats').classList.remove('hidden');
            document.getElementById('totalDistance').textContent = `${totalDistance.toFixed(1)} –∫–º`;
            const timeMinutes = Math.round((totalDistance / 20) * 60 + optimizedAddresses.length * 5);
            const hours = Math.floor(timeMinutes / 60);
            const mins = timeMinutes % 60;
            document.getElementById('totalTime').textContent = hours > 0 ? `${hours}—á ${mins}–º` : `${mins} –º–∏–Ω`;

            // Update address list with new order
            updateAddressList();
        }

        // Initialize speech recognition on load
        document.addEventListener('DOMContentLoaded', () => {
            initSpeechRecognition();
        });
    </script>
</body>
</html>
